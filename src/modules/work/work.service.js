
import { sequelize } from '../../config/database.js';
import { DebtCase, FlowPolicy, InteractionLog, PaymentAgreement } from '../../models/index.js'; // Assuming models exist
import { logger } from '../../utils/logger.js';
import { Op } from 'sequelize';

export const workService = {
    runWorker: async (tenantId, options = {}) => {
        const { limit = 50, dryRun = false } = options;

        // Find due cases
        const dueCases = await DebtCase.findAll({
            where: {
                tenantId,
                status: { [Op.notIn]: ['PAID', 'CLOSED'] },
                nextActionAt: { [Op.lte]: new Date() }
            },
            include: [{ model: FlowPolicy, as: 'flowPolicy' }], // Assuming association exists
            limit: limit,
            order: [['next_action_at', 'ASC']]
        });

        if (dueCases.length === 0) {
            return { message: 'No cases due for processing', processed: 0 };
        }

        const results = [];

        for (const debtCase of dueCases) {
            // If dry run, just list what would happen
            if (dryRun) {
                results.push({
                    caseId: debtCase.id,
                    action: 'WOULD_PROCESS',
                    policy: debtCase.flowPolicy ? debtCase.flowPolicy.name : 'NO_POLICY'
                });
                continue;
            }

            const t = await sequelize.transaction();
            try {
                // Logic: Determine action based on policy
                // For MVP, we cycle actions or pick one based on complexity.
                // Let's assume we just create a "CALL" log if policy allows calls, or "EMAIL".

                const policy = debtCase.flowPolicy;
                let actionType = 'EMAIL'; // Default
                if (policy && policy.channels && policy.channels.call) {
                    actionType = 'CALL';
                }

                // 1. Create Log
                const log = await InteractionLog.create({
                    tenantId,
                    debtCaseId: debtCase.id,
                    channel: actionType,
                    direction: 'OUTBOUND',
                    status: 'COMPLETED', // Simulating instant completion
                    content: `Automated ${actionType} generated by worker based on policy ${policy ? policy.name : 'Unknown'}`,
                    metadata: {
                        triggered_by: 'worker_simulation',
                        policy_id: policy ? policy.id : null
                    }
                }, { transaction: t });

                // 2. Update Case (Move next_action_at)
                // Simple logic: move forward 2 days
                const nextDate = new Date();
                nextDate.setDate(nextDate.getDate() + 2);

                await debtCase.update({
                    nextActionAt: nextDate,
                    updatedAt: new Date()
                }, { transaction: t });

                await t.commit();
                results.push({
                    caseId: debtCase.id,
                    action: actionType,
                    status: 'PROCESSED'
                });

            } catch (error) {
                await t.rollback();
                logger.error({ error, caseId: debtCase.id }, 'Error processing case in worker');
                results.push({
                    caseId: debtCase.id,
                    error: error.message,
                    status: 'ERROR'
                });
            }
        }

        return {
            processed: results.length,
            success: results.filter(r => r.status === 'PROCESSED').length,
            failed: results.filter(r => r.status === 'ERROR').length,
            details: results
        };
    }
};
